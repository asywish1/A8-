import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext
import json
import os
from datetime import datetime, timedelta
import winsound
import threading
import time
import shutil
import sys

class TokenTaskManager:
    def __init__(self, root):
        self.root = root
        self.root.title("A8ç¤¾åŒºä»£å¸äº¤æ˜“ä»»åŠ¡ç®¡ç†ç³»ç»Ÿ")
        self.root.geometry("950x750")
        self.root.resizable(False, False)
        self.root.attributes('-topmost', True)
        
        self.setup_styles()
        
        self.data_dir = os.path.join(os.path.expanduser('~'), 'Documents', 'TokenTaskManager')
        os.makedirs(self.data_dir, exist_ok=True)
        self.config_file = os.path.join(self.data_dir, 'config.json')
        self.tasks_file = os.path.join(self.data_dir, 'tasks.json')
        self.records_file = os.path.join(self.data_dir, 'records.json')
        self.balance_file = os.path.join(self.data_dir, 'balance.json')
        
        self.windows = self.load_config()
        self.tasks = self.load_tasks()
        self.records = self.load_records()
        self.balance_history = self.load_balance_history()
        
        self.create_widgets()
        
        self.running = True
        self.countdown_thread = threading.Thread(target=self.countdown_worker, daemon=True)
        self.alerted_tasks = set()
        self.countdown_thread.start()
        
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)
    
    def setup_styles(self):
        style = ttk.Style()
        style.theme_use('clam')
        
        bg_color = '#f0f0f0'
        accent_color = '#4a90e2'
        dark_color = '#2c3e50'
        
        style.configure('TFrame', background=bg_color)
        style.configure('TLabel', background=bg_color, foreground=dark_color)
        style.configure('TButton', padding=6, relief="flat", background=accent_color)
        style.map('TButton', background=[('active', '#357abd')])
        style.configure('Accent.TButton', background=accent_color, foreground='white')
        style.configure('Danger.TButton', background='#e74c3c', foreground='white')
        style.configure('Success.TButton', background='#27ae60', foreground='white')
        
        style.configure('TNotebook', background=bg_color, borderwidth=0)
        style.configure('TNotebook.Tab', padding=[20, 10], font=('Arial', 10))
        
        style.configure('Card.TFrame', background='white', relief='raised', borderwidth=1)
        style.configure('Title.TLabel', font=('Arial', 11, 'bold'), background='white')
        style.configure('Info.TLabel', font=('Arial', 9), background='white', foreground='#555')
        style.configure('Countdown.TLabel', font=('Arial', 13, 'bold'), background='white')
    
    def load_config(self):
        if os.path.exists(self.config_file):
            with open(self.config_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        return {}
    
    def save_config(self):
        with open(self.config_file, 'w', encoding='utf-8') as f:
            json.dump(self.windows, f, ensure_ascii=False, indent=2)
    
    def load_tasks(self):
        if os.path.exists(self.tasks_file):
            with open(self.tasks_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        return []
    
    def save_tasks(self):
        with open(self.tasks_file, 'w', encoding='utf-8') as f:
            json.dump(self.tasks, f, ensure_ascii=False, indent=2)
    
    def load_records(self):
        if os.path.exists(self.records_file):
            with open(self.records_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        return []
    
    def save_records(self):
        with open(self.records_file, 'w', encoding='utf-8') as f:
            json.dump(self.records, f, ensure_ascii=False, indent=2)
    
    def load_balance_history(self):
        if os.path.exists(self.balance_file):
            with open(self.balance_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        return []
    
    def save_balance_history(self):
        with open(self.balance_file, 'w', encoding='utf-8') as f:
            json.dump(self.balance_history, f, ensure_ascii=False, indent=2)
    
    def create_widgets(self):
        self.notebook = ttk.Notebook(self.root)
        self.notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        self.main_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.main_frame, text="ğŸ“‹ ä»»åŠ¡ç®¡ç†")
        
        self.settings_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.settings_frame, text="âš™ï¸ è®¾ç½®")
        
        self.balance_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.balance_frame, text="ğŸ’° èµ„é‡‘ç®¡ç†")
        
        self.records_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.records_frame, text="ğŸ“Š å¼€ä»“è®°å½•")
        
        self.stats_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.stats_frame, text="ğŸ“ˆ ç»Ÿè®¡")
        
        self.create_main_panel()
        self.create_settings_panel()
        self.create_balance_panel()
        self.create_records_panel()
        self.create_stats_panel()
    
    def create_main_panel(self):
        task_frame = ttk.LabelFrame(self.main_frame, text="ä»»åŠ¡åˆ—è¡¨", padding=10)
        task_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        canvas = tk.Canvas(task_frame, bg='#f0f0f0', highlightthickness=0)
        scrollbar = ttk.Scrollbar(task_frame, orient="vertical", command=canvas.yview)
        self.task_list_frame = ttk.Frame(canvas)
        
        self.task_list_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=self.task_list_frame, anchor="nw", width=880)
        canvas.configure(yscrollcommand=scrollbar.set)
        
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        control_frame = ttk.LabelFrame(self.main_frame, text="æ·»åŠ æ–°ä»»åŠ¡", padding=15)
        control_frame.pack(fill=tk.X, padx=5, pady=5)
        
        row1 = ttk.Frame(control_frame)
        row1.pack(fill=tk.X, pady=5)
        
        ttk.Label(row1, text="ä»£å¸åç§°:", font=('Arial', 9)).pack(side=tk.LEFT, padx=5)
        self.token_name_entry = ttk.Entry(row1, width=15, font=('Arial', 9))
        self.token_name_entry.pack(side=tk.LEFT, padx=5)
        
        ttk.Label(row1, text="å€’è®¡æ—¶(åˆ†é’Ÿ):", font=('Arial', 9)).pack(side=tk.LEFT, padx=5)
        self.countdown_entry = ttk.Entry(row1, width=10, font=('Arial', 9))
        self.countdown_entry.pack(side=tk.LEFT, padx=5)
        
        ttk.Button(row1, text="â• æ·»åŠ ä»»åŠ¡", command=self.add_task, style='Accent.TButton').pack(side=tk.LEFT, padx=10)
        
        ttk.Label(control_frame, text="é€‰æ‹©çª—å£åŠæ•°é‡:", font=('Arial', 9, 'bold')).pack(anchor=tk.W, pady=(10, 5))
        
        self.window_frame = ttk.Frame(control_frame)
        self.window_frame.pack(fill=tk.X, pady=5)
        
        self.window_vars = {}
        self.window_amount_entries = {}
        
        self.refresh_task_list()
        self.refresh_window_checkboxes(self.window_frame)
    
    def refresh_window_checkboxes(self, parent):
        for widget in parent.winfo_children():
            widget.destroy()
        
        self.window_vars = {}
        self.window_amount_entries = {}
        
        col = 0
        row = 0
        max_cols = 3
        
        for window_id, window_name in self.windows.items():
            item_frame = ttk.Frame(parent)
            item_frame.grid(row=row, column=col, sticky=tk.W, padx=10, pady=5)
            
            var = tk.BooleanVar()
            self.window_vars[window_id] = var
            
            cb = ttk.Checkbutton(item_frame, text=f"{window_name} (#{window_id})", variable=var)
            cb.pack(side=tk.LEFT)
            
            ttk.Label(item_frame, text="æ•°é‡:").pack(side=tk.LEFT, padx=(5, 2))
            entry = ttk.Entry(item_frame, width=8)
            entry.pack(side=tk.LEFT)
            self.window_amount_entries[window_id] = entry
            
            col += 1
            if col >= max_cols:
                col = 0
                row += 1
    
    def create_settings_panel(self):
        frame = ttk.LabelFrame(self.settings_frame, text="çª—å£ç®¡ç†", padding=15)
        frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        add_frame = ttk.Frame(frame)
        add_frame.pack(fill=tk.X, pady=10)
        
        ttk.Label(add_frame, text="çª—å£åºå·:", font=('Arial', 9)).pack(side=tk.LEFT, padx=5)
        self.window_id_entry = ttk.Entry(add_frame, width=12)
        self.window_id_entry.pack(side=tk.LEFT, padx=5)
        
        ttk.Label(add_frame, text="çª—å£åç§°:", font=('Arial', 9)).pack(side=tk.LEFT, padx=5)
        self.window_name_entry = ttk.Entry(add_frame, width=20)
        self.window_name_entry.pack(side=tk.LEFT, padx=5)
        
        ttk.Button(add_frame, text="â• æ·»åŠ ", command=self.add_window, style='Success.TButton').pack(side=tk.LEFT, padx=5)
        
        list_frame = ttk.Frame(frame)
        list_frame.pack(fill=tk.BOTH, expand=True, pady=10)
        
        self.window_listbox = tk.Listbox(list_frame, height=20, font=('Arial', 10), 
                                         bg='white', relief=tk.FLAT, borderwidth=1,
                                         selectbackground='#4a90e2', selectforeground='white')
        self.window_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        scrollbar = ttk.Scrollbar(list_frame, orient="vertical", command=self.window_listbox.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.window_listbox.config(yscrollcommand=scrollbar.set)
        
        ttk.Button(frame, text="ğŸ—‘ï¸ åˆ é™¤é€‰ä¸­", command=self.delete_window, style='Danger.TButton').pack(pady=5)
        
        self.refresh_window_list()
    
    def create_balance_panel(self):
        main_frame = ttk.Frame(self.balance_frame)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        update_frame = ttk.LabelFrame(main_frame, text="æ›´æ–°çª—å£èµ„é‡‘", padding=15)
        update_frame.pack(fill=tk.X, pady=(0, 10))
        
        input_frame = ttk.Frame(update_frame)
        input_frame.pack(fill=tk.X, pady=5)
        
        ttk.Label(input_frame, text="é€‰æ‹©çª—å£:", font=('Arial', 9)).pack(side=tk.LEFT, padx=5)
        self.balance_window_var = tk.StringVar()
        self.balance_window_combo = ttk.Combobox(input_frame, textvariable=self.balance_window_var, 
                                                 state='readonly', width=20)
        self.balance_window_combo.pack(side=tk.LEFT, padx=5)
        
        ttk.Label(input_frame, text="å½“å‰é‡‘é¢:", font=('Arial', 9)).pack(side=tk.LEFT, padx=5)
        self.balance_amount_entry = ttk.Entry(input_frame, width=15)
        self.balance_amount_entry.pack(side=tk.LEFT, padx=5)
        
        ttk.Button(input_frame, text="ğŸ’¾ æ›´æ–°", command=self.update_balance, 
                  style='Accent.TButton').pack(side=tk.LEFT, padx=10)
        
        history_frame = ttk.LabelFrame(main_frame, text="èµ„é‡‘å˜åŠ¨å†å²", padding=10)
        history_frame.pack(fill=tk.BOTH, expand=True)
        
        columns = ("æ—¶é—´", "çª—å£", "é‡‘é¢", "å˜åŠ¨")
        self.balance_tree = ttk.Treeview(history_frame, columns=columns, show='headings', height=22)
        
        self.balance_tree.heading("æ—¶é—´", text="æ—¶é—´")
        self.balance_tree.heading("çª—å£", text="çª—å£")
        self.balance_tree.heading("é‡‘é¢", text="å½“å‰é‡‘é¢")
        self.balance_tree.heading("å˜åŠ¨", text="å˜åŠ¨é¢")
        
        self.balance_tree.column("æ—¶é—´", width=180)
        self.balance_tree.column("çª—å£", width=200)
        self.balance_tree.column("é‡‘é¢", width=150)
        self.balance_tree.column("å˜åŠ¨", width=150)
        
        scrollbar = ttk.Scrollbar(history_frame, orient="vertical", command=self.balance_tree.yview)
        self.balance_tree.configure(yscrollcommand=scrollbar.set)
        
        self.balance_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        self.refresh_balance_combo()
        self.refresh_balance_history()
    
    def create_records_panel(self):
        frame = ttk.Frame(self.records_frame)
        frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        columns = ("æ—¶é—´", "ä»£å¸åç§°", "çª—å£", "æ•°é‡")
        self.records_tree = ttk.Treeview(frame, columns=columns, show='headings', height=30)
        
        self.records_tree.heading("æ—¶é—´", text="æ—¶é—´")
        self.records_tree.heading("ä»£å¸åç§°", text="ä»£å¸åç§°")
        self.records_tree.heading("çª—å£", text="çª—å£")
        self.records_tree.heading("æ•°é‡", text="æ•°é‡")
        
        self.records_tree.column("æ—¶é—´", width=180)
        self.records_tree.column("ä»£å¸åç§°", width=200)
        self.records_tree.column("çª—å£", width=250)
        self.records_tree.column("æ•°é‡", width=150)
        
        style = ttk.Style()
        style.configure("Treeview", rowheight=25, font=('Arial', 9))
        style.configure("Treeview.Heading", font=('Arial', 10, 'bold'))
        
        scrollbar = ttk.Scrollbar(frame, orient="vertical", command=self.records_tree.yview)
        self.records_tree.configure(yscrollcommand=scrollbar.set)
        
        self.records_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        self.refresh_records_list()
    
    def create_stats_panel(self):
        frame = ttk.Frame(self.stats_frame)
        frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # æŒ‰é’®è¡Œï¼šåˆ·æ–°ç»Ÿè®¡ + åˆå§‹åŒ–è½¯ä»¶
        btn_row = ttk.Frame(frame)
        btn_row.pack(pady=10, anchor=tk.W)
        ttk.Button(btn_row, text="ğŸ”„ åˆ·æ–°ç»Ÿè®¡", command=self.refresh_stats, style='Accent.TButton').pack(side=tk.LEFT, padx=(0,8))
        ttk.Button(btn_row, text="âš ï¸ åˆå§‹åŒ–è½¯ä»¶", command=self.initialize_app, style='Danger.TButton').pack(side=tk.LEFT)
        
        self.stats_text = scrolledtext.ScrolledText(frame, height=30, width=95, 
                                                     font=('Consolas', 10),
                                                     bg='white', relief=tk.FLAT, borderwidth=1)
        self.stats_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        self.stats_text.tag_configure('header', font=('Arial', 12, 'bold'), foreground='#2c3e50')
        self.stats_text.tag_configure('subheader', font=('Arial', 11, 'bold'), foreground='#34495e')
        self.stats_text.tag_configure('value', font=('Consolas', 10), foreground='#27ae60')
        self.stats_text.tag_configure('label', font=('Arial', 10), foreground='#555')
        self.stats_text.tag_configure('separator', foreground='#bdc3c7')
        
        self.refresh_stats()
    
    def add_window(self):
        window_id = self.window_id_entry.get().strip()
        window_name = self.window_name_entry.get().strip()
        
        if not window_id or not window_name:
            messagebox.showwarning("è­¦å‘Š", "è¯·å¡«å†™å®Œæ•´ä¿¡æ¯")
            return
        
        if window_id in self.windows:
            messagebox.showwarning("è­¦å‘Š", "è¯¥çª—å£åºå·å·²å­˜åœ¨")
            return
        
        self.windows[window_id] = window_name
        self.save_config()
        self.refresh_window_list()
        self.refresh_balance_combo()
        self.refresh_window_checkboxes(self.window_frame)
        
        self.window_id_entry.delete(0, tk.END)
        self.window_name_entry.delete(0, tk.END)
        messagebox.showinfo("æˆåŠŸ", "çª—å£æ·»åŠ æˆåŠŸ")
    
    def delete_window(self):
        selection = self.window_listbox.curselection()
        if not selection:
            messagebox.showwarning("è­¦å‘Š", "è¯·é€‰æ‹©è¦åˆ é™¤çš„çª—å£")
            return
        
        window_id = list(self.windows.keys())[selection[0]]
        del self.windows[window_id]
        self.save_config()
        self.refresh_window_list()
        self.refresh_balance_combo()
        self.refresh_window_checkboxes(self.window_frame)
        messagebox.showinfo("æˆåŠŸ", "çª—å£åˆ é™¤æˆåŠŸ")
    
    def refresh_window_list(self):
        self.window_listbox.delete(0, tk.END)
        for window_id, window_name in self.windows.items():
            self.window_listbox.insert(tk.END, f"#{window_id} - {window_name}")
    
    def refresh_balance_combo(self):
        values = [f"#{wid} - {name}" for wid, name in self.windows.items()]
        self.balance_window_combo['values'] = values
        if values:
            self.balance_window_combo.current(0)
    
    def update_balance(self):
        if not self.balance_window_var.get():
            messagebox.showwarning("è­¦å‘Š", "è¯·é€‰æ‹©çª—å£")
            return
        
        amount_str = self.balance_amount_entry.get().strip()
        if not amount_str:
            messagebox.showwarning("è­¦å‘Š", "è¯·è¾“å…¥é‡‘é¢")
            return
        
        try:
            amount = float(amount_str)
        except ValueError:
            messagebox.showwarning("è­¦å‘Š", "é‡‘é¢å¿…é¡»æ˜¯æ•°å­—")
            return
        
        window_text = self.balance_window_var.get()
        window_id = window_text.split(' - ')[0][1:]
        window_name = self.windows[window_id]
        
        last_balance = None
        for record in reversed(self.balance_history):
            if record['window_id'] == window_id:
                last_balance = record['amount']
                break
        
        change = amount - last_balance if last_balance is not None else 0
        
        record = {
            'time': datetime.now().isoformat(),
            'window_id': window_id,
            'window_name': window_name,
            'amount': amount,
            'change': change
        }
        
        self.balance_history.append(record)
        self.save_balance_history()
        self.refresh_balance_history()
        
        self.balance_amount_entry.delete(0, tk.END)
        messagebox.showinfo("æˆåŠŸ", f"èµ„é‡‘æ›´æ–°æˆåŠŸ\nå˜åŠ¨: {change:+.2f}")
    
    def refresh_balance_history(self):
        self.balance_tree.delete(*self.balance_tree.get_children())
        
        for record in reversed(self.balance_history):
            time_str = datetime.fromisoformat(record['time']).strftime('%Y-%m-%d %H:%M:%S')
            change_str = f"{record['change']:+.2f}" if record['change'] != 0 else "é¦–æ¬¡è®°å½•"
            
            item = self.balance_tree.insert('', 0, values=(
                time_str,
                f"{record['window_name']} (#{record['window_id']})",
                f"{record['amount']:.2f}",
                change_str
            ))
            
            if record['change'] > 0:
                self.balance_tree.item(item, tags=('positive',))
            elif record['change'] < 0:
                self.balance_tree.item(item, tags=('negative',))
        
        self.balance_tree.tag_configure('positive', foreground='#27ae60')
        self.balance_tree.tag_configure('negative', foreground='#e74c3c')
    
    def add_task(self):
        token_name = self.token_name_entry.get().strip()
        countdown_minutes = self.countdown_entry.get().strip()
        
        if not token_name or not countdown_minutes:
            messagebox.showwarning("è­¦å‘Š", "è¯·å¡«å†™ä»£å¸åç§°å’Œå€’è®¡æ—¶æ—¶é—´")
            return
        
        try:
            countdown_minutes = int(countdown_minutes)
        except ValueError:
            messagebox.showwarning("è­¦å‘Š", "å€’è®¡æ—¶æ—¶é—´å¿…é¡»æ˜¯æ•°å­—")
            return
        
        selected_windows = {}
        for window_id, var in self.window_vars.items():
            if var.get():
                amount = self.window_amount_entries[window_id].get().strip()
                if not amount:
                    messagebox.showwarning("è­¦å‘Š", f"è¯·å¡«å†™çª—å£ #{window_id} çš„å¼€ä»“æ•°é‡")
                    return
                try:
                    amount = float(amount)
                    selected_windows[window_id] = amount
                except ValueError:
                    messagebox.showwarning("è­¦å‘Š", "å¼€ä»“æ•°é‡å¿…é¡»æ˜¯æ•°å­—")
                    return
        
        if not selected_windows:
            messagebox.showwarning("è­¦å‘Š", "è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªçª—å£")
            return
        
        end_time = datetime.now() + timedelta(minutes=countdown_minutes)
        task = {
            'id': len(self.tasks),
            'token_name': token_name,
            'windows': selected_windows,
            'countdown_minutes': countdown_minutes,
            'end_time': end_time.isoformat(),
            'created_time': datetime.now().isoformat()
        }
        
        self.tasks.append(task)
        self.save_tasks()
        
        for window_id, amount in selected_windows.items():
            record = {
                'time': datetime.now().isoformat(),
                'token_name': token_name,
                'window_id': window_id,
                'window_name': self.windows.get(window_id, 'æœªçŸ¥'),
                'amount': amount
            }
            self.records.append(record)
        self.save_records()
        
        self.token_name_entry.delete(0, tk.END)
        self.countdown_entry.delete(0, tk.END)
        for var in self.window_vars.values():
            var.set(False)
        for entry in self.window_amount_entries.values():
            entry.delete(0, tk.END)
        
        self.refresh_task_list()
        self.refresh_records_list()
        messagebox.showinfo("æˆåŠŸ", "ä»»åŠ¡æ·»åŠ æˆåŠŸ")
    
    def edit_task(self, task_id):
        task = next((t for t in self.tasks if t['id'] == task_id), None)
        if not task:
            return
        
        edit_window = tk.Toplevel(self.root)
        edit_window.title("ä¿®æ”¹ä»»åŠ¡")
        edit_window.geometry("400x300")
        edit_window.transient(self.root)
        edit_window.grab_set()
        
        frame = ttk.Frame(edit_window, padding=20)
        frame.pack(fill=tk.BOTH, expand=True)
        
        ttk.Label(frame, text="ä»£å¸åç§°:", font=('Arial', 10)).pack(anchor=tk.W, pady=5)
        token_entry = ttk.Entry(frame, width=30)
        token_entry.insert(0, task['token_name'])
        token_entry.pack(pady=5)
        
        ttk.Label(frame, text="å»¶é•¿æ—¶é—´(åˆ†é’Ÿ):", font=('Arial', 10)).pack(anchor=tk.W, pady=5)
        extend_entry = ttk.Entry(frame, width=30)
        extend_entry.pack(pady=5)
        
        def save_changes():
            new_name = token_entry.get().strip()
            extend_minutes = extend_entry.get().strip()
            
            if new_name:
                task['token_name'] = new_name
            
            if extend_minutes:
                try:
                    extend = int(extend_minutes)
                    end_time = datetime.fromisoformat(task['end_time'])
                    end_time += timedelta(minutes=extend)
                    task['end_time'] = end_time.isoformat()
                except ValueError:
                    messagebox.showwarning("è­¦å‘Š", "å»¶é•¿æ—¶é—´å¿…é¡»æ˜¯æ•°å­—")
                    return
            
            self.save_tasks()
            self.refresh_task_list()
            edit_window.destroy()
            messagebox.showinfo("æˆåŠŸ", "ä»»åŠ¡ä¿®æ”¹æˆåŠŸ")
        
        ttk.Button(frame, text="ä¿å­˜", command=save_changes, style='Accent.TButton').pack(pady=20)
    
    def delete_task(self, task_id):
        if messagebox.askyesno("ç¡®è®¤", "ç¡®å®šè¦åˆ é™¤è¿™ä¸ªä»»åŠ¡å—?"):
            self.tasks = [t for t in self.tasks if t['id'] != task_id]
            self.save_tasks()
            self.refresh_task_list()
            messagebox.showinfo("æˆåŠŸ", "ä»»åŠ¡åˆ é™¤æˆåŠŸ")
    
    def complete_task(self, task_id):
        if not messagebox.askyesno("ç¡®è®¤", "ç¡®å®šå·²å®Œæˆè¿™ä¸ªä»»åŠ¡å—? (å°†é‡æ–°å¼€å§‹å€’è®¡æ—¶)"):
            return

        task = next((t for t in self.tasks if t['id'] == task_id), None)
        if not task:
            return

        # é‡æ–°è®¾ç½®ç»“æŸæ—¶é—´ä¸ºå½“å‰æ—¶é—´ + åŸå§‹å€’è®¡æ—¶æ—¶é•¿ï¼ˆä¿ç•™å¼€ä»“è®°å½•ä¸ç»Ÿè®¡ï¼‰
        minutes = int(task.get('countdown_minutes', 0))
        task['end_time'] = (datetime.now() + timedelta(minutes=minutes)).isoformat()

        # å…è®¸å†æ¬¡æé†’
        if hasattr(self, 'alerted_tasks'):
            self.alerted_tasks.discard(task_id)

        self.save_tasks()
        self.refresh_task_list()
        messagebox.showinfo("æˆåŠŸ", "ä»»åŠ¡å·²é‡æ–°å€’è®¡æ—¶")
    
    def refresh_task_list(self):
        for widget in self.task_list_frame.winfo_children():
            widget.destroy()
        
        sorted_tasks = sorted(self.tasks, key=lambda x: x['end_time'])
        
        for i, task in enumerate(sorted_tasks):
            self.create_task_widget(task, i)
    
    def create_task_widget(self, task, row):
        frame = ttk.Frame(self.task_list_frame, style='Card.TFrame', padding=12)
        frame.grid(row=row, column=0, sticky=tk.EW, padx=5, pady=6)
        self.task_list_frame.columnconfigure(0, weight=1)
        
        info_frame = ttk.Frame(frame, style='Card.TFrame')
        info_frame.pack(fill=tk.X)
        
        token_label = ttk.Label(info_frame, text=f"ğŸª™ {task['token_name']}", 
                               font=('Arial', 11, 'bold'), background='white', foreground='#2c3e50')
        token_label.pack(anchor=tk.W, pady=(0, 5))
        
        windows_text = "  |  ".join([f"{self.windows.get(wid, 'æœªçŸ¥')}(#{wid}): {amt}" 
                                     for wid, amt in task['windows'].items()])
        windows_label = ttk.Label(info_frame, text=f"ğŸ“Š {windows_text}", style='Info.TLabel')
        windows_label.pack(anchor=tk.W, pady=(0, 8))
        
        countdown_label = ttk.Label(info_frame, text="", style='Countdown.TLabel')
        countdown_label.pack(anchor=tk.W, pady=(0, 8))
        countdown_label.task_id = task['id']
        
        btn_frame = ttk.Frame(frame, style='Card.TFrame')
        btn_frame.pack(fill=tk.X)
        
        ttk.Button(btn_frame, text="âœï¸ ä¿®æ”¹", command=lambda: self.edit_task(task['id']), 
                  width=8).pack(side=tk.LEFT, padx=3)
        ttk.Button(btn_frame, text="ğŸ—‘ï¸ åˆ é™¤", command=lambda: self.delete_task(task['id']), 
                  style='Danger.TButton', width=8).pack(side=tk.LEFT, padx=3)
        ttk.Button(btn_frame, text="âœ… å®Œæˆ", command=lambda: self.complete_task(task['id']), 
                  style='Success.TButton', width=8).pack(side=tk.LEFT, padx=3)
    
    def countdown_worker(self):
        """å€’è®¡æ—¶å·¥ä½œçº¿ç¨‹"""
        while self.running:
            try:
                for widget in self.task_list_frame.winfo_children():
                    if isinstance(widget, ttk.Frame):
                        for child in widget.winfo_children():
                            if isinstance(child, ttk.Frame):
                                for label in child.winfo_children():
                                    if isinstance(label, ttk.Label) and hasattr(label, 'task_id'):
                                        task = next((t for t in self.tasks if t['id'] == label.task_id), None)
                                        if task:
                                            end_time = datetime.fromisoformat(task['end_time'])
                                            remaining = end_time - datetime.now()
                                            
                                            if remaining.total_seconds() <= 0:
                                                label.configure(text="â° æ—¶é—´åˆ°!", foreground='#e74c3c')
                                                
                                                if task['id'] not in self.alerted_tasks:
                                                    self.alerted_tasks.add(task['id'])
                                                    self.root.after(0, lambda t=task: self.alert_task(t))
                                            else:
                                                hours = int(remaining.total_seconds() // 3600)
                                                minutes = int((remaining.total_seconds() % 3600) // 60)
                                                seconds = int(remaining.total_seconds() % 60)
                                                
                                                if hours > 0:
                                                    countdown_text = f"â±ï¸ å‰©ä½™: {hours}å°æ—¶ {minutes}åˆ†é’Ÿ {seconds}ç§’"
                                                else:
                                                    countdown_text = f"â±ï¸ å‰©ä½™: {minutes}åˆ†é’Ÿ {seconds}ç§’"
                                                
                                                if remaining.total_seconds() <= 60:
                                                    label.configure(text=countdown_text, foreground='#e74c3c')
                                                elif remaining.total_seconds() <= 300:
                                                    label.configure(text=countdown_text, foreground='#f39c12')
                                                else:
                                                    label.configure(text=countdown_text, foreground='#27ae60')
                
                time.sleep(1)
            except:
                pass
    
    def alert_task(self, task):
        """ä»»åŠ¡åˆ°æœŸæé†’"""
        try:
            winsound.Beep(1000, 500)
            winsound.Beep(1200, 500)
            winsound.Beep(1000, 500)
        except:
            pass
        
        messagebox.showinfo("ä»»åŠ¡æé†’", f"ä»»åŠ¡ '{task['token_name']}' æ—¶é—´åˆ°äº†!")
    
    def refresh_records_list(self):
        """åˆ·æ–°å¼€ä»“è®°å½•åˆ—è¡¨"""
        self.records_tree.delete(*self.records_tree.get_children())
        
        for record in reversed(self.records):
            time_str = datetime.fromisoformat(record['time']).strftime('%Y-%m-%d %H:%M:%S')
            self.records_tree.insert('', 0, values=(
                time_str,
                record['token_name'],
                f"{record['window_name']} (#{record['window_id']})",
                f"{record['amount']:.2f}"
            ))
    
    def refresh_stats(self):
        """åˆ·æ–°ç»Ÿè®¡ä¿¡æ¯"""
        self.stats_text.delete(1.0, tk.END)
        
        if not self.records:
            self.stats_text.insert(tk.END, "æš‚æ— å¼€ä»“è®°å½•\n", 'header')
            return
        
        total_count = len(self.records)
        total_amount = sum(r['amount'] for r in self.records)
        
        self.stats_text.insert(tk.END, "â”Œ" + "â”€" * 78 + "â”\n", 'separator')
        self.stats_text.insert(tk.END, "â”‚", 'separator')
        self.stats_text.insert(tk.END, " ğŸ“Š æ€»ä½“ç»Ÿè®¡".ljust(76), 'header')
        self.stats_text.insert(tk.END, "  â”‚\n", 'separator')
        self.stats_text.insert(tk.END, "â””" + "â”€" * 78 + "â”˜\n\n", 'separator')
        
        self.stats_text.insert(tk.END, "  æ€»å¼€ä»“æ¬¡æ•°: ", 'label')
        self.stats_text.insert(tk.END, f"{total_count} æ¬¡\n", 'value')
        self.stats_text.insert(tk.END, "  æ€»å¼€ä»“é‡‘é¢: ", 'label')
        self.stats_text.insert(tk.END, f"{total_amount:.2f}\n\n", 'value')
        
        window_stats = {}
        for record in self.records:
            wid = record['window_id']
            wname = record['window_name']
            if wid not in window_stats:
                window_stats[wid] = {'name': wname, 'count': 0, 'amount': 0}
            window_stats[wid]['count'] += 1
            window_stats[wid]['amount'] += record['amount']
        
        self.stats_text.insert(tk.END, "\nâ”Œ" + "â”€" * 78 + "â”\n", 'separator')
        self.stats_text.insert(tk.END, "â”‚", 'separator')
        self.stats_text.insert(tk.END, " ğŸªŸ å„çª—å£ç»Ÿè®¡".ljust(76), 'header')
        self.stats_text.insert(tk.END, "  â”‚\n", 'separator')
        self.stats_text.insert(tk.END, "â””" + "â”€" * 78 + "â”˜\n\n", 'separator')
        
        for wid, stats in sorted(window_stats.items()):
            self.stats_text.insert(tk.END, f"  çª—å£ #{wid} - {stats['name']}\n", 'subheader')
            self.stats_text.insert(tk.END, "    å¼€ä»“æ¬¡æ•°: ", 'label')
            self.stats_text.insert(tk.END, f"{stats['count']} æ¬¡\n", 'value')
            self.stats_text.insert(tk.END, "    å¼€ä»“é‡‘é¢: ", 'label')
            self.stats_text.insert(tk.END, f"{stats['amount']:.2f}\n", 'value')
            self.stats_text.insert(tk.END, "    å¹³å‡é‡‘é¢: ", 'label')
            self.stats_text.insert(tk.END, f"{stats['amount']/stats['count']:.2f}\n\n", 'value')
        
        token_stats = {}
        for record in self.records:
            token = record['token_name']
            if token not in token_stats:
                token_stats[token] = {'count': 0, 'amount': 0}
            token_stats[token]['count'] += 1
            token_stats[token]['amount'] += record['amount']
        
        self.stats_text.insert(tk.END, "\nâ”Œ" + "â”€" * 78 + "â”\n", 'separator')
        self.stats_text.insert(tk.END, "â”‚", 'separator')
        self.stats_text.insert(tk.END, " ğŸª™ å„ä»£å¸ç»Ÿè®¡".ljust(76), 'header')
        self.stats_text.insert(tk.END, "  â”‚\n", 'separator')
        self.stats_text.insert(tk.END, "â””" + "â”€" * 78 + "â”˜\n\n", 'separator')
        
        for token, stats in sorted(token_stats.items(), key=lambda x: x[1]['amount'], reverse=True):
            self.stats_text.insert(tk.END, f"  ä»£å¸: {token}\n", 'subheader')
            self.stats_text.insert(tk.END, "    å¼€ä»“æ¬¡æ•°: ", 'label')
            self.stats_text.insert(tk.END, f"{stats['count']} æ¬¡\n", 'value')
            self.stats_text.insert(tk.END, "    å¼€ä»“é‡‘é¢: ", 'label')
            self.stats_text.insert(tk.END, f"{stats['amount']:.2f}\n", 'value')
            self.stats_text.insert(tk.END, "    å¹³å‡é‡‘é¢: ", 'label')
            self.stats_text.insert(tk.END, f"{stats['amount']/stats['count']:.2f}\n\n", 'value')
        
        if self.balance_history:
            self.stats_text.insert(tk.END, "\nâ”Œ" + "â”€" * 78 + "â”\n", 'separator')
            self.stats_text.insert(tk.END, "â”‚", 'separator')
            self.stats_text.insert(tk.END, " ğŸ’° èµ„é‡‘ç»Ÿè®¡".ljust(76), 'header')
            self.stats_text.insert(tk.END, "  â”‚\n", 'separator')
            self.stats_text.insert(tk.END, "â””" + "â”€" * 78 + "â”˜\n\n", 'separator')
            
            window_balance = {}
            for record in self.balance_history:
                wid = record['window_id']
                if wid not in window_balance or datetime.fromisoformat(record['time']) > datetime.fromisoformat(window_balance[wid]['time']):
                    window_balance[wid] = record
            
            total_balance = sum(r['amount'] for r in window_balance.values())
            
            self.stats_text.insert(tk.END, "  æ€»èµ„é‡‘: ", 'label')
            self.stats_text.insert(tk.END, f"{total_balance:.2f}\n\n", 'value')
            
            for wid, record in sorted(window_balance.items()):
                self.stats_text.insert(tk.END, f"  {record['window_name']} (#{wid}): ", 'label')
                self.stats_text.insert(tk.END, f"{record['amount']:.2f}\n", 'value')
    
    def initialize_app(self):
        """åˆå§‹åŒ–è½¯ä»¶ï¼šå¤‡ä»½ç°æœ‰æ•°æ®å¹¶æ¸…ç©ºé…ç½®/ä»»åŠ¡/è®°å½•/èµ„é‡‘ï¼Œç„¶åé‡å¯ç¨‹åº"""
        if not messagebox.askyesno("ç¡®è®¤åˆå§‹åŒ–", "åˆå§‹åŒ–å°†æ¸…ç©ºæ‰€æœ‰çª—å£é…ç½®ã€ä»»åŠ¡ã€å¼€ä»“è®°å½•å’Œèµ„é‡‘å†å²ï¼Œå¹¶é‡å¯ç¨‹åºã€‚\nå·²å­˜åœ¨çš„æ•°æ®ä¼šå¤‡ä»½ã€‚ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ"):
            return

        # å¤‡ä»½ç°æœ‰æ•°æ®æ–‡ä»¶
        ts = datetime.now().strftime("%Y%m%d%H%M%S")
        try:
            for f in (self.config_file, self.tasks_file, self.records_file, self.balance_file):
                if os.path.exists(f):
                    shutil.copy(f, f"{f}.bak.{ts}")
        except Exception as e:
            messagebox.showwarning("å¤‡ä»½å¤±è´¥", f"å¤‡ä»½è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯ï¼š{e}")
            return

        # æ¸…ç©ºå†…å­˜æ•°æ®å¹¶å†™å…¥ç©ºæ–‡ä»¶
        self.windows = {}
        self.tasks = []
        self.records = []
        self.balance_history = []
        try:
            self.save_config()
            self.save_tasks()
            self.save_records()
            self.save_balance_history()
        except Exception as e:
            messagebox.showwarning("ä¿å­˜å¤±è´¥", f"æ¸…ç©ºæ•°æ®æ—¶å‡ºé”™ï¼š{e}")
            return

        # åˆ·æ–°ç•Œé¢
        try:
            self.refresh_window_list()
            self.refresh_balance_combo()
            self.refresh_window_checkboxes(self.window_frame)
            self.refresh_task_list()
            self.refresh_records_list()
            self.refresh_balance_history()
            self.refresh_stats()
        except:
            pass

        messagebox.showinfo("å®Œæˆ", "åˆå§‹åŒ–å®Œæˆï¼Œå·²å¤‡ä»½åŸæ•°æ®å¹¶æ¸…ç©ºå½“å‰æ•°æ®ã€‚ç¨‹åºå°†é‡å¯ã€‚")

        # é‡å¯ç¨‹åº
        try:
            self.running = False
            python = sys.executable
            os.execv(python, [python] + sys.argv)
        except Exception:
            messagebox.showinfo("é‡å¯å¤±è´¥", "è‡ªåŠ¨é‡å¯å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨é‡æ–°å¯åŠ¨ç¨‹åºã€‚")
    
    def on_closing(self):
        """å…³é—­ç¨‹åº"""
        self.running = False
        self.root.destroy()


if __name__ == "__main__":
    root = tk.Tk()
    app = TokenTaskManager(root)
    root.mainloop()
